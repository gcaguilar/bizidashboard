# Phase 1, Plan 03 — Timezone Handling & DST Support

**Objective:** Implement UTC timestamp storage with Europe/Madrid timezone conversion utilities and comprehensive DST transition handling.

**Purpose:** Prevent DST errors (Pitfall #4) by ensuring all timestamps are stored in UTC and converted to Europe/Madrid only for display. Handle March/October transitions correctly to avoid missing or duplicate hours.

**Output:** Timezone utilities in src/lib/timezone.ts, DST handling in src/lib/dst.ts, comprehensive test suite with DST edge cases, and documentation of timezone strategy.

**Type:** execute
**Wave:** 3
**Dependencies:** 01-02-PLAN.md (schema must exist with timestamp fields)
**Autonomous:** true

## Must-Haves

**Observable Truths:**
1. All timestamps stored in database are UTC (offset 0)
2. Display conversion to Europe/Madrid shows correct local time with offset
3. March DST transition (02:00→03:00) doesn't lose data
4. October DST transition (03:00→02:00) handles ambiguous hour correctly
5. IANA timezone name "Europe/Madrid" used (not "CET" or "CEST" abbreviations)

**Required Artifacts:**
- `src/lib/timezone.ts` — UTC storage and Europe/Madrid conversion functions
- `src/lib/dst.ts` — DST transition detection and handling
- `tests/timezone.test.ts` — Unit tests for conversion functions
- `tests/dst.test.ts` — DST transition edge case tests
- `docs/timezone-strategy.md` — Documentation of approach

**Key Links:**
- Prisma DateTime fields → UTC storage via timezone.ts
- UI display → Europe/Madrid conversion via timezone.ts
- DST transitions → special handling in dst.ts
- Tests verify no data loss during transitions

## Tasks

### Task 1: Implement UTC Storage Utilities
**Type:** auto
**Priority:** MUST

**Action:**
Create src/lib/timezone.ts with functions: `toUTC(date: Date): Date` (ensure UTC), `toEuropeMadrid(date: Date): string` (format for display with offset), `getEuropeMadridOffset(date: Date): number` (returns offset in minutes, +60 or +120). Use Intl.DateTimeFormat for proper IANA timezone handling.

**Implementation Requirements:**
- Use native Intl API (no moment-timezone, no date-fns-tz)
- Store timestamps as ISO 8601 UTC strings in database
- Display format includes offset indicator (e.g., "14:30 CEST" or "14:30 CET")
- Handle edge cases: null/undefined dates, invalid dates

**Code Structure:**
```typescript
// src/lib/timezone.ts
export const TIMEZONE = 'Europe/Madrid'

export function toUTC(date: Date): Date {
  // Ensure date is treated as UTC for storage
  return new Date(date.toISOString())
}

export function toEuropeMadrid(date: Date): string {
  // Format for display: "2024-03-31T14:30:00+02:00 (CEST)"
  // Use Intl.DateTimeFormat with timeZone: 'Europe/Madrid'
}

export function getEuropeMadridOffset(date: Date): number {
  // Returns offset in minutes from UTC (+60 winter, +120 summer)
  // Use Intl.DateTimeFormat with timeZoneName: 'shortOffset'
}

export function isDST(date: Date): boolean {
  // Returns true if date is in DST period (late March to late October)
  // Check if offset is +120 minutes
}
```

**Verification:**
- `npx tsc --noEmit` passes
- Unit tests pass (see Task 3)
- Test conversions manually:
  - Winter (Jan 15): should show +01:00 offset
  - Summer (Jul 15): should show +02:00 offset

**Done When:**
- All three functions implemented
- TypeScript compiles without errors
- Functions handle edge cases (invalid dates, null values)

---

### Task 2: Implement DST Transition Handling
**Type:** auto
**Priority:** MUST

**Action:**
Create src/lib/dst.ts with functions to handle DST transitions: `getDSTTransitions(year: number): { spring: Date, fall: Date }` (calculate exact transition dates), `isAmbiguousHour(date: Date): boolean` (detect fall-back ambiguous hour), `isMissingHour(date: Date): boolean` (detect spring-forward gap), `normalizeForStorage(date: Date): Date` (ensure UTC for storage). DST transitions occur last Sunday of March (02:00→03:00) and October (03:00→02:00).

**Critical DST Rules for Europe/Madrid:**
- **Spring Forward:** Last Sunday of March at 02:00 local time → 03:00 (1 hour disappears)
- **Fall Back:** Last Sunday of October at 03:00 local time → 02:00 (1 hour repeats)

**Implementation Requirements:**
- Calculate exact transition dates algorithmically (not hardcoded)
- Handle "missing hour" in March (02:00-02:59 doesn't exist on transition day)
- Handle "ambiguous hour" in October (02:00-02:59 happens twice)
- Always store UTC timestamp (unambiguous)
- Document strategy for ambiguous timestamps

**Code Structure:**
```typescript
// src/lib/dst.ts
export function getDSTTransitions(year: number): { spring: Date, fall: Date } {
  // Calculate last Sunday of March and October
  // Return UTC dates of transitions
}

export function isMissingHour(date: Date): boolean {
  // Check if date falls in the gap (02:00-02:59 local on last Sunday of March)
  // Return true if this local time doesn't exist
}

export function isAmbiguousHour(date: Date): boolean {
  // Check if date falls in the ambiguous hour (02:00-02:59 on last Sunday of October)
  // Return true if this local time occurs twice
}

export function normalizeForStorage(date: Date): Date {
  // Convert any date to UTC for database storage
  // Handle edge cases: if missing hour, adjust to start of valid period
  // If ambiguous, prefer first occurrence or document the choice
}
```

**Verification:**
- Calculate 2024 transitions: March 31, October 27
- Calculate 2025 transitions: March 30, October 26
- Verify against known DST dates
- Functions return correct boolean for edge cases

**Done When:**
- DST transition dates calculated correctly
- Missing/ambiguous hour detection works
- Normalization function handles all edge cases

---

### Task 3: Create Comprehensive DST Test Suite
**Type:** auto
**Priority:** MUST

**Action:**
Create tests/dst.test.ts with test cases covering: winter non-DST dates, summer DST dates, spring transition (March 31, 2024 at 01:59, 02:00 [invalid], 03:00), fall transition (October 27, 2024 at 01:59, 02:00 [first], 02:30 [first], 02:00 [second], 03:00), and timezone conversion round-trip tests. Use Vitest or Jest (match Next.js testing setup).

**Test Cases Required:**

1. **Basic offset tests:**
   - Jan 15, 2024 → offset +60 minutes (CET)
   - Jul 15, 2024 → offset +120 minutes (CEST)

2. **Spring transition (March 31, 2024):**
   - 01:59 local → exists, offset +60
   - 02:00 local → doesn't exist (missing hour)
   - 02:30 local → doesn't exist (missing hour)
   - 03:00 local → exists, offset +120
   - 03:01 local → exists, offset +120

3. **Fall transition (October 27, 2024):**
   - 01:59 local (first occurrence) → offset +120
   - 02:00 local (first occurrence, CEST) → offset +120
   - 02:30 local (first occurrence, CEST) → offset +120
   - 02:00 local (second occurrence, CET) → offset +60
   - 02:30 local (second occurrence, CET) → offset +60
   - 03:00 local → offset +60

4. **Storage round-trip:**
   - Local date → toUTC → toEuropeMadrid → should match original local time (or closest valid)

**Implementation:**
```typescript
// tests/dst.test.ts
import { describe, it, expect } from 'vitest'
import { toUTC, toEuropeMadrid, getEuropeMadridOffset, isDST } from '../src/lib/timezone'
import { getDSTTransitions, isMissingHour, isAmbiguousHour } from '../src/lib/dst'

describe('DST Transitions 2024', () => {
  it('calculates correct spring transition date', () => {
    const transitions = getDSTTransitions(2024)
    expect(transitions.spring.toISOString()).toBe('2024-03-31T01:00:00.000Z') // 02:00 local
  })
  
  it('handles missing hour in spring', () => {
    const missingHour = new Date('2024-03-31T02:30:00+01:00') // This time doesn't exist
    expect(isMissingHour(missingHour)).toBe(true)
  })
  
  // ... more tests
})
```

**Verification:**
- `npm test` (or `npx vitest`) runs all tests
- All 10+ test cases pass
- Tests document DST behavior clearly

**Done When:**
- Test suite created with comprehensive cases
- All tests pass
- Tests serve as documentation for DST behavior

## Verification

**Overall Phase 03 Verification:**
1. `src/lib/timezone.ts` exports working conversion functions
2. `src/lib/dst.ts` handles DST transitions correctly
3. `npm test` passes all timezone and DST tests
4. Manual verification:
   - Winter date shows CET (+01:00)
   - Summer date shows CEST (+02:00)
   - Spring transition documented (missing hour)
   - Fall transition documented (ambiguous hour)
5. Documentation exists explaining approach

**Manual Test Commands:**
```bash
# Winter (should show +01:00 offset)
node -e "const {getEuropeMadridOffset} = require('./src/lib/timezone'); console.log(getEuropeMadridOffset(new Date('2024-01-15')));"

# Summer (should show +02:00 offset)
node -e "const {getEuropeMadridOffset} = require('./src/lib/timezone'); console.log(getEuropeMadridOffset(new Date('2024-07-15')));"
```

## Success Criteria

- [ ] UTC storage function (`toUTC`) ensures consistent UTC timestamps
- [ ] Europe/Madrid display conversion (`toEuropeMadrid`) shows correct offset
- [ ] DST transition dates calculated correctly for any year
- [ ] Spring transition gap (missing hour) detected
- [ ] Fall transition overlap (ambiguous hour) detected
- [ ] Test suite covers all DST edge cases (10+ tests)
- [ ] All tests pass
- [ ] Documentation explains timezone strategy

## Output

After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` documenting:
- Timezone utility functions and their usage
- DST transition handling approach
- Test results and edge cases covered
- Integration notes for Plan 04 (how timestamps flow through the system)

---

**Estimated Context Usage:** ~45%
**Estimated Execution Time:** 60-75 minutes
