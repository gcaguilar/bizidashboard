# Phase 1, Plan 02 — Database Schema & Time-Series Structure

**Objective:** Design and implement Prisma schema for Bizi station data with time-series optimization, including Station and StationStatus models with proper indexes.

**Purpose:** Establish data structures that support efficient time-series queries for station status history. This schema must handle 130 stations × 48 readings/day = 6,240 records/day without performance degradation.

**Output:** Prisma schema with Station and StationStatus models, composite indexes for time-series queries, and initial migration applied.

**Type:** execute
**Wave:** 2
**Dependencies:** 01-01-PLAN.md (Prisma must be configured)
**Autonomous:** true

## Must-Haves

**Observable Truths:**
1. Station model stores static metadata (ID, name, location, capacity)
2. StationStatus model stores time-series data (bikes available, anchors free, timestamp)
3. Queries by stationId + timestamp range use index (not full table scan)
4. Foreign key relationship enforces data integrity
5. Migration applies successfully without data loss

**Required Artifacts:**
- `prisma/schema.prisma` — Station and StationStatus models
- `prisma/migrations/` — Initial migration with indexes
- `src/types/station.ts` — TypeScript types mirroring schema
- Test query demonstrating index usage (EXPLAIN QUERY PLAN)

**Key Links:**
- Station.id → StationStatus.stationId (foreign key)
- StationStatus.timestamp indexed for range queries
- Composite index on [stationId, timestamp] for time-series lookups

## Tasks

### Task 1: Design Station Model
**Type:** auto
**Priority:** MUST

**Action:**
Add Station model to prisma/schema.prisma with fields: id (String, unique, from Bizi API), name (String), lat (Float), lon (Float), capacity (Int), isActive (Boolean, default true). Use String for ID to match Bizi's station identifiers.

**Schema Addition:**
```prisma
model Station {
  id          String   @id
  name        String
  lat         Float
  lon         Float
  capacity    Int
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  statuses  StationStatus[]
  
  @@index([isActive])
  @@index([lat, lon])
}
```

**Verification:**
- `npx prisma validate` passes with new model
- Model has all required fields
- Relationships defined correctly

**Done When:**
- Station model added to schema
- Validation passes
- Model supports station metadata storage

---

### Task 2: Design StationStatus Time-Series Model
**Type:** auto
**Priority:** MUST

**Action:**
Add StationStatus model for time-series data: id (auto-increment), stationId (String, FK), bikesAvailable (Int), anchorsFree (Int), recordedAt (DateTime), createdAt (DateTime default now). Critical: Use separate id field for time-series records, not composite key (SQLite limitation with autoincrement).

**Schema Addition:**
```prisma
model StationStatus {
  id              Int      @id @default(autoincrement())
  stationId       String
  bikesAvailable  Int
  anchorsFree     Int
  recordedAt      DateTime // UTC timestamp from Bizi API
  createdAt       DateTime @default(now()) // When we recorded it
  
  station Station @relation(fields: [stationId], references: [id])
  
  @@index([stationId, recordedAt]) // Critical for time-series queries
  @@index([recordedAt]) // For range queries across all stations
}
```

**Important Design Decisions:**
- `recordedAt` stores the timestamp from Bizi API (in UTC)
- `createdAt` stores when our system received the data
- Separate auto-increment id because SQLite doesn't support composite keys with autoincrement
- Composite index on [stationId, recordedAt] for efficient time-series lookups

**Verification:**
- Schema validates: `npx prisma validate`
- Relationship to Station is correct
- Indexes are defined for time-series access patterns

**Done When:**
- StationStatus model added
- Composite index defined
- Foreign key relationship established

---

### Task 3: Create Migration and Verify Indexes
**Type:** auto
**Priority:** MUST

**Action:**
Generate initial migration with `npx prisma migrate dev --name init_schema`, apply it, then verify indexes are created using SQLite EXPLAIN QUERY PLAN. Create a test script that demonstrates index usage.

**Commands:**
```bash
npx prisma migrate dev --name init_schema
npx prisma generate
```

**Verification Script (create test-schema.ts):**
```typescript
import { prisma } from './src/lib/db'

async function testIndexes() {
  // Test 1: Insert a station
  await prisma.station.create({
    data: { id: 'test-001', name: 'Test Station', lat: 41.65, lon: -0.88, capacity: 20 }
  })
  
  // Test 2: Insert a status record
  await prisma.stationStatus.create({
    data: { stationId: 'test-001', bikesAvailable: 10, anchorsFree: 10, recordedAt: new Date() }
  })
  
  // Test 3: Query with index (should use stationId_recordedAt index)
  const recent = await prisma.stationStatus.findMany({
    where: { stationId: 'test-001', recordedAt: { gte: new Date(Date.now() - 86400000) } },
    orderBy: { recordedAt: 'desc' },
    take: 10
  })
  
  console.log('Index test passed:', recent.length >= 0)
}

testIndexes().finally(() => prisma.$disconnect())
```

**Verification:**
- Migration applies without errors
- Database file contains tables with correct columns
- Test script runs successfully
- Query planner shows index usage (check with SQLite CLI: `EXPLAIN QUERY PLAN SELECT ...`)

**Done When:**
- Migration file created in prisma/migrations/
- Database schema matches Prisma models
- Indexes verified via query plan
- Can insert and query test data

## Verification

**Overall Phase 02 Verification:**
1. `prisma/schema.prisma` contains Station and StationStatus models
2. `npx prisma db pull` (or inspect) confirms tables exist with indexes
3. SQLite CLI shows indexes: `.indexes StationStatus` shows stationId + recordedAt index
4. Test script demonstrates CRUD operations work
5. Foreign key constraints prevent orphaned status records

**Index Verification (run in SQLite):**
```sql
.schema StationStatus
-- Should show: CREATE INDEX StationStatus_stationId_recordedAt_idx ON StationStatus(stationId, recordedAt)
```

## Success Criteria

- [ ] Station model with metadata fields (id, name, lat, lon, capacity, isActive)
- [ ] StationStatus model with time-series fields (id, stationId, bikesAvailable, anchorsFree, recordedAt, createdAt)
- [ ] Foreign key relationship Station ↔ StationStatus
- [ ] Composite index on [stationId, recordedAt] for time-series queries
- [ ] Index on [recordedAt] for date range queries
- [ ] Migration applies successfully
- [ ] Can insert and query test data

## Output

After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` documenting:
- Schema design rationale (why separate id, why specific indexes)
- Index verification results
- Sample queries and their performance characteristics
- Notes for Plan 03 timezone handling

---

**Estimated Context Usage:** ~40%
**Estimated Execution Time:** 45-60 minutes
