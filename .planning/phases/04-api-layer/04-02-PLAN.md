---
phase: 04-api-layer
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified: [src/analytics/queries/read.ts, src/app/api/stations/route.ts, src/app/api/rankings/route.ts, src/app/api/alerts/route.ts]
autonomous: true

must_haves:
  truths:
    - "GET /api/stations returns stations with latest status"
    - "GET /api/rankings returns sorted station rankings by turnover or availability"
    - "GET /api/alerts returns active prediction alerts"
  artifacts:
    - path: "src/analytics/queries/read.ts"
      provides: "Read helper for stations with latest status"
      exports: ["getStationsWithLatestStatus"]
    - path: "src/app/api/stations/route.ts"
      provides: "Stations list API endpoint"
      exports: ["GET"]
    - path: "src/app/api/rankings/route.ts"
      provides: "Rankings API endpoint"
      exports: ["GET"]
    - path: "src/app/api/alerts/route.ts"
      provides: "Alerts API endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/stations/route.ts"
      to: "src/analytics/queries/read.ts"
      via: "getStationsWithLatestStatus"
      pattern: "getStationsWithLatestStatus"
    - from: "src/app/api/rankings/route.ts"
      to: "src/analytics/queries/read.ts"
      via: "getStationRankings"
      pattern: "getStationRankings"
    - from: "src/app/api/alerts/route.ts"
      to: "src/analytics/queries/read.ts"
      via: "getActiveAlerts"
      pattern: "getActiveAlerts"
    - from: "src/app/api/*/route.ts"
      to: "src/lib/cache/cache.ts"
      via: "cache helpers"
      pattern: "withCache|getCachedJson"
---

<objective>
Expose station list, rankings, and alerts REST endpoints.

Purpose: Serve API-01, API-02, and API-05 with Redis-backed caching.
Output: Three route handlers and a station-status read helper.
</objective>

<execution_context>
@/home/guichu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/guichu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-api-layer/04-RESEARCH.md
@src/analytics/queries/read.ts
@src/app/api/status/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add station list read helper</name>
  <files>src/analytics/queries/read.ts</files>
  <action>
Add `getStationsWithLatestStatus()` that returns each station with its most recent status (bikesAvailable, anchorsFree, recordedAt). Use a single SQL query with a subquery or CTE to select the latest `recordedAt` per station and join `Station` + `StationStatus`. Filter out inactive stations (`isActive = true`) and order results by station name. Keep the return shape API-ready with station metadata and status fields.
  </action>
  <verify>pnpm exec tsc --noEmit</verify>
  <done>Read helper returns one row per active station with latest status and timestamp.</done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/stations</name>
  <files>src/app/api/stations/route.ts</files>
  <action>
Implement a Route Handler with `GET` that returns `{ stations, generatedAt }` using `getStationsWithLatestStatus()`. Add `export const dynamic = 'force-dynamic'` (or `revalidate = 0`) to prevent Next.js response caching. Wrap the read with Redis cache-aside using key `stations:current` and TTL 300 seconds. Respond with `NextResponse.json` and include `Cache-Control: public, max-age=300, stale-while-revalidate=60`.
  </action>
  <verify>pnpm exec tsc --noEmit</verify>
  <done>Stations endpoint returns latest statuses and uses Redis cache with 5-minute TTL.</done>
</task>

<task type="auto">
  <name>Task 3: Create GET /api/rankings and GET /api/alerts</name>
  <files>src/app/api/rankings/route.ts, src/app/api/alerts/route.ts</files>
  <action>
Add `/api/rankings` with `type=turnover|availability` and optional `limit` (default 20). Validate query params and return 400 on invalid input. Use `getStationRankings(type, limit)` and cache with key `rankings:type={type}:limit={limit}`. Add `/api/alerts` with optional `limit` (default 50), use `getActiveAlerts(limit)` with cache key `alerts:limit={limit}`. Both handlers should set `dynamic = 'force-dynamic'` (or `revalidate = 0`) and return JSON with proper status codes and cache-control headers.
  </action>
  <verify>pnpm exec tsc --noEmit</verify>
  <done>Rankings and alerts endpoints validate params, return JSON, and use Redis cache with 5-minute TTL.</done>
</task>

</tasks>

<verification>
- `pnpm exec tsc --noEmit`
</verification>

<success_criteria>
- `/api/stations`, `/api/rankings`, and `/api/alerts` respond with JSON and proper status codes.
- All three endpoints use cache-aside Redis with 5-minute TTL keys that include query params.
</success_criteria>

<output>
After completion, create `.planning/phases/04-api-layer/04-02-SUMMARY.md`
</output>
