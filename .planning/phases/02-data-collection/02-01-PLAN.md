---
phase: 02-data-collection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/retry.ts
  - src/schemas/gbfs.ts
  - src/services/gbfs-client.ts
  - src/types/gbfs.ts
autonomous: true

must_haves:
  truths:
    - "GBFS discovery file can be fetched and parsed"
    - "Station status endpoint discovered dynamically from discovery"
    - "API calls retry with exponential backoff and jitter"
    - "GBFS responses validated against Zod schemas"
    - "Version-agnostic parsing allows future GBFS upgrades"
  artifacts:
    - path: "src/lib/retry.ts"
      provides: "Exponential backoff with jitter for HTTP retries"
      exports: ["withRetry"]
    - path: "src/schemas/gbfs.ts"
      provides: "Zod schemas for GBFS validation"
      exports: ["StationStatusSchema", "GBFSResponseSchema", "GBFSDiscoverySchema"]
    - path: "src/services/gbfs-client.ts"
      provides: "GBFS API wrapper with retry"
      exports: ["fetchDiscovery", "fetchStationStatus"]
    - path: "src/types/gbfs.ts"
      provides: "TypeScript types from Zod schemas"
      exports: ["StationStatus", "GBFSResponse", "GBFSDiscovery"]
  key_links:
    - from: "src/services/gbfs-client.ts"
      to: "src/lib/retry.ts"
      via: "withRetry wrapper"
      pattern: "withRetry.*fetch"
    - from: "src/services/gbfs-client.ts"
      to: "src/schemas/gbfs.ts"
      via: "Zod validation"
      pattern: "schema\.parse|safeParse"
---

<objective>
Build the GBFS API client infrastructure with resilient HTTP requests, schema validation, and version-agnostic discovery parsing.

Purpose: This is the foundation of the data pipeline. Without reliable API access and validation, no data can be collected. The GBFS client must handle network failures gracefully and validate data before it reaches storage.

Output: Complete GBFS client service with retry logic, Zod schemas, and TypeScript types ready for data collection.
</objective>

<execution_context>
@/home/guichu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/guichu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-collection/02-RESEARCH.md
@prisma/schema.prisma

## Prior Phase Context (Phase 1 Complete)

Database schema exists with:
- Station model (id, name, lat, lon, capacity, isActive)
- StationStatus model (id, stationId, bikesAvailable, anchorsFree, recordedAt, createdAt)
- Prisma client configured with LibSQL adapter
- UTC timestamp storage (from Phase 1)

## Bizi API Details (from RESEARCH.md)

- GBFS v2.3 (but version-agnostic required)
- Discovery: https://zaragoza.publicbikesystem.net/customer/gbfs/v2/gbfs.json
- Station Status: Discovered dynamically from discovery file
- ~276 stations expected
- No authentication required
- Unix timestamps in seconds (convert to milliseconds for JS Date)

## GBFS Response Structure

```json
{
  "last_updated": 1770324668,  // Unix seconds
  "ttl": 1,
  "version": "2.3",
  "data": {
    "stations": [
      {
        "station_id": "string",
        "num_bikes_available": 0,
        "num_docks_available": 0,
        "is_installed": true,
        "is_renting": true,
        "is_returning": true,
        "last_reported": 1770324668
      }
    ]
  }
}
```

## Research Recommendations

- Use native fetch (not axios) for smaller bundle
- Use retry-axios OR implement custom retry with exponential backoff + jitter
- Use Zod for validation with .passthrough() for version-agnostic parsing
- Include User-Agent header: "BiziDashboard/1.0"
- Handle timestamp conversion: GBFS seconds â†’ JS milliseconds
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Retry Utility with Exponential Backoff</name>
  <files>src/lib/retry.ts</files>
  <action>
    Create src/lib/retry.ts with a withRetry function that implements exponential backoff with jitter.

    Requirements:
    - Function signature: withRetry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>
    - RetryOptions: maxRetries (default 5), baseDelay (default 1000ms)
    - Exponential backoff: delay = baseDelay * 2^attempt
    - Add jitter: random 0-1000ms to prevent thundering herd
    - Only retry on network errors and 5xx/429 responses
    - Throw last error if all retries exhausted
    - Export sleep helper function for testing

    Implementation notes:
    - Use native fetch error detection (TypeError for network errors)
    - Check response status for HTTP errors
    - Log retry attempts with console.warn for observability
    - Don't retry on 4xx errors (except 429 rate limit)

    Example usage:
    ```typescript
    const data = await withRetry(() => fetch(url).then(r => r.json()));
    ```
  </action>
  <verify>
    - File src/lib/retry.ts exists and exports withRetry
    - TypeScript compiles without errors (npm run type-check or tsc --noEmit)
  </verify>
  <done>
    Retry utility implemented with exponential backoff, jitter, and proper error classification
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod Schemas for GBFS Validation</name>
  <files>src/schemas/gbfs.ts</files>
  <action>
    Create src/schemas/gbfs.ts with Zod schemas for GBFS validation.

    Required schemas:
    1. StationStatusSchema - individual station status
       - station_id: string (required)
       - num_bikes_available: number, int, >= 0
       - num_docks_available: number, int, >= 0
       - is_installed: boolean
       - is_renting: boolean
       - is_returning: boolean
       - last_reported: number (unix timestamp in seconds)
       - Use .passthrough() to allow extra fields (version-agnostic)

    2. GBFSResponseSchema - wrapper response
       - last_updated: number (unix timestamp)
       - ttl: number
       - version: string
       - data: object with stations array

    3. GBFSDiscoverySchema - discovery file structure
       - last_updated: number
       - ttl: number
       - version: string
       - data: object with en.feeds array
       - Each feed has name (string) and url (string)

    Also export:
    - TypeScript types using z.infer<typeof Schema>
    - validateStationData function that uses safeParse and throws on error with details
    - Helper to extract station_status URL from discovery

    Important:
    - All number fields are integers (use z.number().int())
    - Use .passthrough() on all object schemas for forward compatibility
    - Validation function should log errors before throwing for observability
  </action>
  <verify>
    - File src/schemas/gbfs.ts exists with all three schemas
    - Types exported: StationStatus, GBFSResponse, GBFSDiscovery
    - npm run type-check passes
    - Can import and use schemas in another file
  </verify>
  <done>
    Zod schemas created for GBFS discovery, response, and station status with TypeScript types and validation function
  </done>
</task>

<task type="auto">
  <name>Task 3: Create GBFS Client Service</name>
  <files>src/services/gbfs-client.ts</files>
  <action>
    Create src/services/gbfs-client.ts that orchestrates discovery, fetch, and validation.

    Required exports:
    1. fetchDiscovery(): Promise<GBFSDiscovery>
       - Fetch https://zaragoza.publicbikesystem.net/customer/gbfs/v2/gbfs.json
       - Use withRetry for resilience
       - Include User-Agent: "BiziDashboard/1.0" header
       - Validate response with GBFSDiscoverySchema
       - Return typed discovery object

    2. fetchStationStatus(discovery?: GBFSDiscovery): Promise<GBFSResponse>
       - If discovery not provided, call fetchDiscovery() first
       - Find station_status URL from discovery.data.en.feeds
       - Throw if station_status feed not found
       - Fetch with retry and User-Agent header
       - Validate with GBFSResponseSchema
       - Return typed response

    3. extractStationStatusUrl(discovery: GBFSDiscovery): string | null
       - Helper to find station_status URL from feeds array
       - Return null if not found

    Error handling:
    - Wrap fetch errors with context ("Failed to fetch GBFS discovery")
    - Include URL in error messages for debugging
    - Log successful fetches with station count

    Implementation notes:
    - Use native fetch API (Node 18+)
    - Timeout requests at 10 seconds
    - Convert GBFS unix timestamps (seconds) to Date objects where needed
    - All functions should be async and return promises
  </action>
  <verify>
    - File src/services/gbfs-client.ts exists with all exports
    - Can call fetchDiscovery() and get validated discovery object
    - Can call fetchStationStatus() and get validated station data
    - TypeScript compiles without errors
  </verify>
  <done>
    GBFS client service complete with discovery parsing, station status fetching, retry logic, and validation
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. GBFS client can fetch discovery file and parse it
2. Station status URL extracted dynamically (not hardcoded)
3. Retry logic has exponential backoff with jitter
4. All responses validated with Zod before returning
5. TypeScript types flow from schemas to client
6. User-Agent header included on all requests
</verification>

<success_criteria>
- src/lib/retry.ts exports working withRetry function with exponential backoff
- src/schemas/gbfs.ts defines StationStatusSchema, GBFSResponseSchema, GBFSDiscoverySchema
- src/services/gbfs-client.ts can fetch and validate GBFS data
- All files compile with TypeScript
- Discovery file parsing is version-agnostic (uses feeds array)
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-collection/02-01-SUMMARY.md`
</output>
