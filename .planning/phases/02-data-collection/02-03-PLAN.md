---
phase: 02-data-collection
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/jobs/bizi-collection.ts
  - src/app/api/collect/route.ts
autonomous: true

must_haves:
  truths:
    - "Cron job runs every 30 minutes automatically"
    - "Collection can be triggered manually via API endpoint"
    - "Each run fetches, validates, and stores station data"
    - "Errors logged but don't crash the job"
    - "Job reports success/failure with metrics"
  artifacts:
    - path: "src/jobs/bizi-collection.ts"
      provides: "Scheduled data collection job"
      exports: ["startCollectionJob", "runCollection"]
    - path: "src/app/api/collect/route.ts"
      provides: "Manual trigger endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/jobs/bizi-collection.ts"
      to: "src/services/gbfs-client.ts"
      via: "fetchStationStatus"
      pattern: "fetchStationStatus"
    - from: "src/jobs/bizi-collection.ts"
      to: "src/services/data-validator.ts"
      via: "validateAndStore"
      pattern: "validateAndStore"
    - from: "src/app/api/collect/route.ts"
      to: "src/jobs/bizi-collection.ts"
      via: "runCollection"
      pattern: "runCollection"
---

<objective>
Create the scheduled collection job that runs every 30 minutes and a manual trigger API endpoint.

Purpose: Automates the data collection pipeline on a schedule while allowing manual triggering for testing and recovery. The job orchestrates fetch → validate → store with proper error handling.

Output: Working cron job scheduled every 30 minutes with API endpoint for manual collection.
</objective>

<execution_context>
@/home/guichu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/guichu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-collection/02-RESEARCH.md

## Prior Plans Context

Plan 02-01 provides:
- fetchDiscovery(), fetchStationStatus() in src/services/gbfs-client.ts
- Retry logic with exponential backoff
- Zod schema validation

Plan 02-02 provides:
- validateAndStore() in src/services/data-validator.ts
- storeStationStatuses() in src/services/data-storage.ts
- validateDataQuality() in src/lib/observability.ts

## Requirements (from ROADMAP.md)

DATA-01: Automated polling of Bizi API every 30 minutes
- Cron schedule: */30 * * * * (every 30 minutes)
- Timezone: Europe/Madrid

DATA-05: Error handling with exponential backoff for rate limiting
- Already handled in gbfs-client.ts retry logic
- Job-level error handling: catch and log, don't crash

INFRA-04: Data observability (freshness alerts, volume checks)
- validateDataQuality provides these checks
- Need to surface metrics from each run

## Scheduling Requirements

- Run every 30 minutes
- Use node-cron library
- Europe/Madrid timezone (respects DST)
- Run immediately on startup (runOnInit: true)
- Handle errors gracefully (log but continue)

## Manual Trigger Endpoint

- POST /api/collect
- Authentication: Optional for MVP (can add later)
- Returns: Collection result with metrics
- Use case: Testing, recovery, forced refresh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Scheduled Collection Job</name>
  <files>src/jobs/bizi-collection.ts</files>
  <action>
    Create src/jobs/bizi-collection.ts with the main collection job logic.

    Required exports:
    1. runCollection(): Promise<CollectionResult>
       - Main collection function that can be called directly
       - Steps:
         a. Log start: "[Collection] Starting Bizi data collection..."
         b. Call fetchStationStatus() to get GBFS data
         c. Call validateAndStore() to process and store data
         d. Log success: "[Collection] Successfully collected N stations"
         e. Return CollectionResult with:
            * success: boolean
            * stationCount: number
            * recordedAt: Date
            * quality: DataObservabilityMetrics
            * duration: number (ms)
            * warnings: string[]
       - Error handling:
         * Wrap in try/catch
         * Log error: "[Collection] Failed: {error.message}"
         * Return CollectionResult with success=false
         * Re-throw for upstream handling
       - Track duration: Date.now() before/after

    2. startCollectionJob(): void
       - Initialize node-cron scheduler
       - Schedule: */30 * * * * (every 30 minutes)
       - Timezone: 'Europe/Madrid'
       - runOnInit: true (run immediately on startup)
       - On tick: call runCollection().catch(err => console.error)
       - Log when scheduler starts: "[Cron] Bizi collection scheduled every 30 minutes"

    3. stopCollectionJob(): void
       - Stop the cron job (for testing/shutdown)
       - Log: "[Cron] Collection job stopped"

    4. CollectionResult interface
       - success: boolean
       - stationCount: number
       - recordedAt: Date | null
       - quality: DataObservabilityMetrics | null
       - duration: number
       - warnings: string[]
       - error?: string
       - timestamp: Date (when collection completed)

    5. JobState interface and getJobState()
       - lastRun: Date | null
       - lastSuccess: Date | null
       - consecutiveFailures: number
       - totalRuns: number
       - totalSuccesses: number
       - Returns current state for observability

    Implementation notes:
    - Import fetchStationStatus from '@/services/gbfs-client'
    - Import validateAndStore from '@/services/data-validator'
    - Import DataObservabilityMetrics from '@/lib/observability'
    - Import cron from 'node-cron'
    - Store job state in module-level variables
    - Update state after each run (success/failure tracking)
    - If consecutiveFailures >= 3, log warning: "[Collection] 3 consecutive failures"
  </action>
  <verify>
    - File src/jobs/bizi-collection.ts exists with all exports
    - TypeScript compiles without errors
    - runCollection function orchestrates full pipeline
    - startCollectionJob sets up cron schedule
  </verify>
  <done>
    Collection job complete with scheduled execution, manual run capability, and state tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Manual Collection API Endpoint</name>
  <files>src/app/api/collect/route.ts</files>
  <action>
    Create src/app/api/collect/route.ts as a Next.js API route for manual collection.

    Requirements:
    1. POST handler
       - Call runCollection() from '@/jobs/bizi-collection'
       - Return JSON response:
         * On success (200):
           {
             success: true,
             stationCount: number,
             recordedAt: string (ISO),
             quality: DataObservabilityMetrics,
             duration: number,
             warnings: string[],
             timestamp: string (ISO)
           }
         * On error (500):
           {
             success: false,
             error: string,
             timestamp: string (ISO)
           }

    2. GET handler (optional, for status check)
       - Call getJobState() to get current job state
       - Return JSON with:
         * lastRun: string | null (ISO)
         * lastSuccess: string | null (ISO)
         * consecutiveFailures: number
         * totalRuns: number
         * totalSuccesses: number
         * isScheduled: boolean

    3. Authentication consideration
       - For MVP: No authentication (simplest)
       - Add comment: "TODO: Add API key auth for production"
       - Or check for secret header: X-API-Key (compare to env var)

    Error handling:
    - Wrap runCollection in try/catch
    - Return 500 on error with error message
    - Log all requests: "[API] Collection triggered via POST /api/collect"

    Implementation notes:
    - Use Next.js 13+ Route Handler format
    - Export async function POST(request: Request)
    - Call runCollection() and await result
    - Format dates as ISO strings in JSON
    - Include all quality metrics in response
  </action>
  <verify>
    - File src/app/api/collect/route.ts exists
    - POST handler exports correctly
    - Returns proper JSON response format
    - TypeScript compiles without errors
  </verify>
  <done>
    Manual collection endpoint complete at POST /api/collect with metrics response
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Collection Job Bootstrap</name>
  <files>src/lib/jobs.ts</files>
  <action>
    Create src/lib/jobs.ts to bootstrap the collection job on application startup.

    Requirements:
    1. initJobs(): void
       - Check if running in production or development mode
       - Call startCollectionJob() from '@/jobs/bizi-collection'
       - Log: "[Jobs] Initializing background jobs..."
       - Log: "[Jobs] Collection job started"

    2. shutdownJobs(): void
       - Call stopCollectionJob() for graceful shutdown
       - Log: "[Jobs] Shutting down background jobs..."

    3. Environment detection
       - Only start jobs if NOT in test environment
       - Check process.env.NODE_ENV !== 'test'
       - Add comment explaining this prevents tests from starting cron jobs

    Implementation notes:
    - Import startCollectionJob, stopCollectionJob from '@/jobs/bizi-collection'
    - This file is called from app layout or middleware on startup
    - For Next.js, jobs should be initialized in:
      * app/layout.tsx (server component) - preferred for MVP
      * or middleware.ts - if needs to run on every request
    - Add clear comment about where this is called from
  </action>
  <verify>
    - File src/lib/jobs.ts exists with initJobs and shutdownJobs
    - TypeScript compiles without errors
    - Exports are properly typed
  </verify>
  <done>
    Job bootstrap module ready to initialize collection on app startup
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Cron job scheduled to run every 30 minutes
2. Manual trigger available at POST /api/collect
3. Job orchestrates full pipeline: fetch → validate → store
4. Errors caught and logged, don't crash the process
5. Job state tracked (last run, successes, failures)
6. API returns collection metrics in JSON
</verification>

<success_criteria>
- src/jobs/bizi-collection.ts exports runCollection and startCollectionJob
- Cron schedule: */30 * * * * with Europe/Madrid timezone
- src/app/api/collect/route.ts handles POST requests
- Job state tracked (lastRun, consecutiveFailures, etc.)
- CollectionResult includes stationCount, quality metrics, duration
- All files compile with TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-collection/02-03-SUMMARY.md`
</output>
